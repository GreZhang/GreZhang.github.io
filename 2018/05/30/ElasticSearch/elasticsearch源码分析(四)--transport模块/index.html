<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="elasticsearch,源码分析," />





  <link rel="alternate" href="/atom.xml" title="Gre的博客" type="application/atom+xml" />






<meta name="description" content="通过上一篇对Elasticsearch Discovery的分析，我们知道了ES Discovery的主要是用来做发现协议的，它包含了master选举、集群状态更新等功能，而在这一过程当中也依赖了Transport模块，但是我们一直没有谈论，本篇着重来分析Transport模块是做什么的，我们先来提出几个问题？  Transport模块是用来干什么的？ ES有哪两种Client？ Client如何">
<meta name="keywords" content="elasticsearch,源码分析">
<meta property="og:type" content="article">
<meta property="og:title" content="elasticsearch源码分析(四)--transport模块">
<meta property="og:url" content="https://grezhang.github.io/2018/05/30/ElasticSearch/elasticsearch源码分析(四)--transport模块/index.html">
<meta property="og:site_name" content="Gre的博客">
<meta property="og:description" content="通过上一篇对Elasticsearch Discovery的分析，我们知道了ES Discovery的主要是用来做发现协议的，它包含了master选举、集群状态更新等功能，而在这一过程当中也依赖了Transport模块，但是我们一直没有谈论，本篇着重来分析Transport模块是做什么的，我们先来提出几个问题？  Transport模块是用来干什么的？ ES有哪两种Client？ Client如何">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="f:/hexo/source/images/es/PreBuiltTransportClient类图.png">
<meta property="og:image" content="f:/hexo/source/images/es/PreBuiltTransportClient类信息.png">
<meta property="og:image" content="f:/hexo/source/images/es/Transport实现类.png">
<meta property="og:image" content="f:/hexo/source/images/es/Netty4Transport类图.png">
<meta property="og:updated_time" content="2018-07-02T02:01:59.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="elasticsearch源码分析(四)--transport模块">
<meta name="twitter:description" content="通过上一篇对Elasticsearch Discovery的分析，我们知道了ES Discovery的主要是用来做发现协议的，它包含了master选举、集群状态更新等功能，而在这一过程当中也依赖了Transport模块，但是我们一直没有谈论，本篇着重来分析Transport模块是做什么的，我们先来提出几个问题？  Transport模块是用来干什么的？ ES有哪两种Client？ Client如何">
<meta name="twitter:image" content="f:/hexo/source/images/es/PreBuiltTransportClient类图.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '123456',
      author: 'Tenken'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://grezhang.github.io/2018/05/30/ElasticSearch/elasticsearch源码分析(四)--transport模块/"/>





  <title>elasticsearch源码分析(四)--transport模块 | Gre的博客</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Gre的博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">风骚的程序员</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-commonweal">
          <a href="/404.html" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            公益404
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://grezhang.github.io/2018/05/30/ElasticSearch/elasticsearch源码分析(四)--transport模块/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Gre World">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Gre的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">elasticsearch源码分析(四)--transport模块</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-30T10:12:57+08:00">
                2018-05-30
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
			
				&nbsp; | &nbsp;
				<span id="/2018/05/30/ElasticSearch/elasticsearch源码分析(四)--transport模块/"class="leancloud_visitors" data-flag-title="elasticsearch源码分析(四)--transport模块">
				&nbsp;阅读次数
				</span>
			
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Elasticsearch源码分析专题/" itemprop="url" rel="index">
                    <span itemprop="name">Elasticsearch源码分析专题</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2018/05/30/ElasticSearch/elasticsearch源码分析(四)--transport模块/" class="leancloud_visitors" data-flag-title="elasticsearch源码分析(四)--transport模块">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>通过上一篇对Elasticsearch Discovery的分析，我们知道了ES Discovery的主要是用来做发现协议的，它包含了master选举、集群状态更新等功能，而在这一过程当中也依赖了Transport模块，但是我们一直没有谈论，本篇着重来分析Transport模块是做什么的，我们先来提出几个问题？</p>
<ul>
<li>Transport模块是用来干什么的？</li>
<li>ES有哪两种Client？</li>
<li>Client如何初始化？</li>
<li>ES有哪两种Client是如何与Nodes通信工作的？</li>
<li>Transport的工作原理？</li>
</ul>
<h3 id="一、Transport模块介绍"><a href="#一、Transport模块介绍" class="headerlink" title="一、Transport模块介绍"></a>一、Transport模块介绍</h3><p>transport模块是es通信的基础模块，在elasticsearch中用的很广泛，比如集群node之间的通信、数据的传输、transport client方式的数据发送等等,只要数和通信、数据传输相关的都离不开transport模块的作用。</p>
<p>先来看官网初始化Client例子：<a href="https://www.elastic.co/guide/en/elasticsearch/client/java-api/5.5/transport-client.html" target="_blank" rel="noopener">TransportClient</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">TransportClient client = <span class="keyword">new</span> PreBuiltTransportClient(Settings.EMPTY)</span><br><span class="line">        .addTransportAddress(<span class="keyword">new</span> InetSocketTransportAddress(InetAddress.getByName(<span class="string">"host1"</span>), <span class="number">9300</span>))</span><br><span class="line">        .addTransportAddress(<span class="keyword">new</span> InetSocketTransportAddress(InetAddress.getByName(<span class="string">"host2"</span>), <span class="number">9300</span>));</span><br><span class="line"></span><br><span class="line">Settings settings = Settings.builder()</span><br><span class="line">        .put(<span class="string">"cluster.name"</span>, <span class="string">"myClusterName"</span>).build();</span><br><span class="line">TransportClient client = <span class="keyword">new</span> PreBuiltTransportClient(settings);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Settings settings = Settings.builder()</span><br><span class="line">        .put(<span class="string">"client.transport.sniff"</span>, <span class="keyword">true</span>).build();</span><br><span class="line">TransportClient client = <span class="keyword">new</span> PreBuiltTransportClient(settings);</span><br></pre></td></tr></table></figure>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/client/java-rest/5.5/_initialization.html" target="_blank" rel="noopener">RestClient</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">RestClient restClient = RestClient.builder(</span><br><span class="line">        <span class="keyword">new</span> HttpHost(<span class="string">"localhost"</span>, <span class="number">9200</span>, <span class="string">"http"</span>),</span><br><span class="line">        <span class="keyword">new</span> HttpHost(<span class="string">"localhost"</span>, <span class="number">9201</span>, <span class="string">"http"</span>)).build();</span><br></pre></td></tr></table></figure>
<p>从官网上的相关资料可以看出，ES的Client有两种，TransportClient和RestClient。</p>
<p>创建一个Client需要以下参数：</p>
<ul>
<li>需要连接到集群的IP地址（最好多填写几个，如果填写一个，同时启用了嗅探，但是填写的这个IP主机挂了，还是不能启动成功）</li>
<li>连接的端口</li>
<li>是否启用嗅探（自动发现集群中的机器）</li>
</ul>
<h3 id="二、源码分析"><a href="#二、源码分析" class="headerlink" title="二、源码分析"></a>二、源码分析</h3><p>上面就是源码的入口：我们先来分析TransportClient类的初始化：</p>
<p>####2.1 TransportClient类的初始化</p>
<h5 id="2-1-1-PreBuiltTransportClient类图关系"><a href="#2-1-1-PreBuiltTransportClient类图关系" class="headerlink" title="2.1.1 PreBuiltTransportClient类图关系"></a>2.1.1 PreBuiltTransportClient类图关系</h5><p><img src="F:\hexo\source\images\es\PreBuiltTransportClient类图.png" alt=":\hexo\source\images\es\PreBuiltTransportClient类图.pn"></p>
<h5 id="2-1-2-PreBuiltTransportClient源码分析"><a href="#2-1-2-PreBuiltTransportClient源码分析" class="headerlink" title="2.1.2 PreBuiltTransportClient源码分析"></a>2.1.2 PreBuiltTransportClient源码分析</h5><p>通过从上面的类图看出，PreBuiltTransportClient类继承了TransportClient类，我们先来看看它最终调用的构造方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PreBuiltTransportClient</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        Settings settings,</span></span></span><br><span class="line"><span class="function"><span class="params">        Collection&lt;Class&lt;? extends Plugin&gt;&gt; plugins,</span></span></span><br><span class="line"><span class="function"><span class="params">        HostFailureListener hostFailureListener)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 调用父类的构造方法：TransportClient</span></span><br><span class="line">        <span class="keyword">super</span>(settings, Settings.EMPTY, addPlugins(plugins, PRE_INSTALLED_PLUGINS), hostFailureListener);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><img src="F:\hexo\source\images\es\PreBuiltTransportClient类信息.png" alt=":\hexo\source\images\es\PreBuiltTransportClient类信息.pn"></p>
<p>同时可以看到，这个类除了构造方法和close()方法外，没有对外提供额外的其他方法，调用时，都是去调用父类的构造方法，为什么要多用这么一个类呢？猜猜是为了扩展。</p>
<p>我们来看TransportClient的构造方法做了什么？</p>
<h5 id="2-1-3-TransportClient类分析："><a href="#2-1-3-TransportClient类分析：" class="headerlink" title="2.1.3 TransportClient类分析："></a>2.1.3 TransportClient类分析：</h5><h6 id="2-1-3-1-参数"><a href="#2-1-3-1-参数" class="headerlink" title="2.1.3.1 参数"></a>2.1.3.1 参数</h6><p>先来看这个类的几个参数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Setting&lt;TimeValue&gt; CLIENT_TRANSPORT_NODES_SAMPLER_INTERVAL =</span><br><span class="line">    Setting.positiveTimeSetting(<span class="string">"client.transport.nodes_sampler_interval"</span>, timeValueSeconds(<span class="number">5</span>), Setting.Property.NodeScope);</span><br><span class="line"><span class="comment">// ping超时时间，默认5秒</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Setting&lt;TimeValue&gt; CLIENT_TRANSPORT_PING_TIMEOUT =</span><br><span class="line">    Setting.positiveTimeSetting(<span class="string">"client.transport.ping_timeout"</span>, timeValueSeconds(<span class="number">5</span>), Setting.Property.NodeScope);</span><br><span class="line"><span class="comment">// 是否忽略集群名称，默认不忽略</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Setting&lt;Boolean&gt; CLIENT_TRANSPORT_IGNORE_CLUSTER_NAME =</span><br><span class="line">    Setting.boolSetting(<span class="string">"client.transport.ignore_cluster_name"</span>, <span class="keyword">false</span>, Setting.Property.NodeScope);</span><br><span class="line"><span class="comment">// 是否启用嗅探，默认不启用</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Setting&lt;Boolean&gt; CLIENT_TRANSPORT_SNIFF =</span><br><span class="line">    Setting.boolSetting(<span class="string">"client.transport.sniff"</span>, <span class="keyword">false</span>, Setting.Property.NodeScope);</span><br></pre></td></tr></table></figure>
<h6 id="2-1-3-2-构造方法"><a href="#2-1-3-2-构造方法" class="headerlink" title="2.1.3.2 构造方法"></a>2.1.3.2 构造方法</h6><p>PreBuiltTransportClient调用TransportClient的构造方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">TransportClient</span><span class="params">(Settings settings, Settings defaultSettings, Collection&lt;Class&lt;? extends Plugin&gt;&gt; plugins,HostFailureListener hostFailureListener)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// 先调用buildTemplate方法创建ClientTemplate模块实例，然后再调用TransportClient构造方法实例化对象</span></span><br><span class="line">       <span class="keyword">this</span>(buildTemplate(settings, defaultSettings, plugins, hostFailureListener));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="title">TransportClient</span><span class="params">(ClientTemplate template)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// 初始化父类信息</span></span><br><span class="line">       <span class="keyword">super</span>(template.getSettings(), template.getThreadPool());</span><br><span class="line">       <span class="keyword">this</span>.injector = template.injector;</span><br><span class="line">       <span class="keyword">this</span>.pluginLifecycleComponents = Collections.unmodifiableList(template.pluginLifecycleComponents);</span><br><span class="line">       <span class="keyword">this</span>.nodesService = template.nodesService;</span><br><span class="line">       <span class="keyword">this</span>.proxy = template.proxy;</span><br><span class="line">       <span class="keyword">this</span>.namedWriteableRegistry = template.namedWriteableRegistry;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>我们可以看到，在TransportClient的构造方法里，先调用buildTemplate方法创建ClientTemplate模块实例，然后再调用TransportClient构造方法实例化对象，那么TransportClient初始化核心逻辑就应该在buildTemplate()方法里面：</p>
<p>我们先来看看buildTemplate()方法干了什么：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> ClientTemplate <span class="title">buildTemplate</span><span class="params">(Settings providedSettings, Settings defaultSettings,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                Collection&lt;Class&lt;? extends Plugin&gt;&gt; plugins, HostFailureListener failureListner)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// node.name:没有配置，则配置"_client_"</span></span><br><span class="line">        <span class="keyword">if</span> (Node.NODE_NAME_SETTING.exists(providedSettings) == <span class="keyword">false</span>) &#123;</span><br><span class="line">            providedSettings = Settings.builder().put(providedSettings).put(Node.NODE_NAME_SETTING.getKey(), <span class="string">"_client_"</span>).build();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 初始化插件</span></span><br><span class="line">        <span class="keyword">final</span> PluginsService pluginsService = newPluginService(providedSettings, plugins);</span><br><span class="line">        <span class="keyword">final</span> Settings settings = Settings.builder().put(defaultSettings).put(pluginsService.updatedSettings()).build();</span><br><span class="line">        <span class="keyword">final</span> List&lt;Closeable&gt; resourcesToClose = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">// 创建线程池：核心</span></span><br><span class="line">        <span class="keyword">final</span> ThreadPool threadPool = <span class="keyword">new</span> ThreadPool(settings);</span><br><span class="line">        resourcesToClose.add(() -&gt; ThreadPool.terminate(threadPool, <span class="number">10</span>, TimeUnit.SECONDS));</span><br><span class="line">        <span class="comment">// 初始化网络设置</span></span><br><span class="line">        <span class="keyword">final</span> NetworkService networkService = <span class="keyword">new</span> NetworkService(settings, Collections.emptyList());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> List&lt;Setting&lt;?&gt;&gt; additionalSettings = <span class="keyword">new</span> ArrayList&lt;&gt;(pluginsService.getPluginSettings());</span><br><span class="line">            <span class="keyword">final</span> List&lt;String&gt; additionalSettingsFilter = <span class="keyword">new</span> ArrayList&lt;&gt;(pluginsService.getPluginSettingsFilter());</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">final</span> ExecutorBuilder&lt;?&gt; builder : threadPool.builders()) &#123;</span><br><span class="line">                additionalSettings.addAll(builder.getRegisteredSettings());</span><br><span class="line">            &#125;</span><br><span class="line">            SettingsModule settingsModule = <span class="keyword">new</span> SettingsModule(settings, additionalSettings, additionalSettingsFilter);</span><br><span class="line"></span><br><span class="line">            SearchModule searchModule = <span class="keyword">new</span> SearchModule(settings, <span class="keyword">true</span>, pluginsService.filterPlugins(SearchPlugin.class));</span><br><span class="line">            List&lt;NamedWriteableRegistry.Entry&gt; entries = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            entries.addAll(NetworkModule.getNamedWriteables());</span><br><span class="line">            entries.addAll(searchModule.getNamedWriteables());</span><br><span class="line">            entries.addAll(ClusterModule.getNamedWriteables());</span><br><span class="line">            entries.addAll(pluginsService.filterPlugins(Plugin.class).stream()</span><br><span class="line">                                         .flatMap(p -&gt; p.getNamedWriteables().stream())</span><br><span class="line">                                         .collect(Collectors.toList()));</span><br><span class="line">            NamedWriteableRegistry namedWriteableRegistry = <span class="keyword">new</span> NamedWriteableRegistry(entries);</span><br><span class="line">            NamedXContentRegistry xContentRegistry = <span class="keyword">new</span> NamedXContentRegistry(Stream.of(</span><br><span class="line">                    searchModule.getNamedXContents().stream(),</span><br><span class="line">                    pluginsService.filterPlugins(Plugin.class).stream()</span><br><span class="line">                            .flatMap(p -&gt; p.getNamedXContent().stream())</span><br><span class="line">                    ).flatMap(Function.identity()).collect(toList()));</span><br><span class="line">            <span class="comment">// 模块构建</span></span><br><span class="line">            ModulesBuilder modules = <span class="keyword">new</span> ModulesBuilder();</span><br><span class="line">            <span class="comment">// plugin modules must be added here, before others or we can get crazy injection errors...</span></span><br><span class="line">            <span class="keyword">for</span> (Module pluginModule : pluginsService.createGuiceModules()) &#123;</span><br><span class="line">                modules.add(pluginModule);</span><br><span class="line">            &#125;</span><br><span class="line">            modules.add(b -&gt; b.bind(ThreadPool.class).toInstance(threadPool));</span><br><span class="line">            ActionModule actionModule = <span class="keyword">new</span> ActionModule(<span class="keyword">true</span>, settings, <span class="keyword">null</span>, settingsModule.getIndexScopedSettings(),</span><br><span class="line">                    settingsModule.getClusterSettings(), settingsModule.getSettingsFilter(), threadPool,</span><br><span class="line">                    pluginsService.filterPlugins(ActionPlugin.class), <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">            modules.add(actionModule);</span><br><span class="line"></span><br><span class="line">            CircuitBreakerService circuitBreakerService = Node.createCircuitBreakerService(settingsModule.getSettings(),</span><br><span class="line">                settingsModule.getClusterSettings());</span><br><span class="line">            resourcesToClose.add(circuitBreakerService);</span><br><span class="line">            BigArrays bigArrays = <span class="keyword">new</span> BigArrays(settings, circuitBreakerService);</span><br><span class="line">            resourcesToClose.add(bigArrays);</span><br><span class="line">            modules.add(settingsModule);</span><br><span class="line">            <span class="comment">// 初始化网络模块</span></span><br><span class="line">            NetworkModule networkModule = <span class="keyword">new</span> NetworkModule(settings, <span class="keyword">true</span>, pluginsService.filterPlugins(NetworkPlugin.class), threadPool,</span><br><span class="line">                bigArrays, circuitBreakerService, namedWriteableRegistry, xContentRegistry, networkService, <span class="keyword">null</span>);</span><br><span class="line">            <span class="keyword">final</span> Transport transport = networkModule.getTransportSupplier().get();</span><br><span class="line">            <span class="keyword">final</span> TransportAddress address;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                address = transport.addressesFromString(<span class="string">"0.0.0.0:0"</span>, <span class="number">1</span>)[<span class="number">0</span>]; <span class="comment">// this is just a dummy transport address</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (UnknownHostException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 初始化TransportService</span></span><br><span class="line">            <span class="keyword">final</span> TransportService transportService = <span class="keyword">new</span> TransportService(settings, transport, threadPool,</span><br><span class="line">                networkModule.getTransportInterceptor(),</span><br><span class="line">                boundTransportAddress -&gt; DiscoveryNode.createLocal(settings, address, UUIDs.randomBase64UUID()), <span class="keyword">null</span>);</span><br><span class="line">            <span class="comment">// 使用GUICE注入到 ModuleBuild</span></span><br><span class="line">            modules.add((b -&gt; &#123;</span><br><span class="line">                b.bind(BigArrays.class).toInstance(bigArrays);</span><br><span class="line">                b.bind(PluginsService.class).toInstance(pluginsService);</span><br><span class="line">                b.bind(CircuitBreakerService.class).toInstance(circuitBreakerService);</span><br><span class="line">                b.bind(NamedWriteableRegistry.class).toInstance(namedWriteableRegistry);</span><br><span class="line">                b.bind(Transport.class).toInstance(transport);</span><br><span class="line">                b.bind(TransportService.class).toInstance(transportService);</span><br><span class="line">                b.bind(NetworkService.class).toInstance(networkService);</span><br><span class="line">            &#125;));</span><br><span class="line">            Injector injector = modules.createInjector();</span><br><span class="line">            <span class="keyword">final</span> TransportClientNodesService nodesService =</span><br><span class="line">                <span class="keyword">new</span> TransportClientNodesService(settings, transportService, threadPool, failureListner == <span class="keyword">null</span></span><br><span class="line">                    ? (t, e) -&gt; &#123;&#125; : failureListner);</span><br><span class="line">            <span class="keyword">final</span> TransportProxyClient proxy = <span class="keyword">new</span> TransportProxyClient(settings, transportService, nodesService,</span><br><span class="line">                actionModule.getActions().values().stream().map(x -&gt; x.getAction()).collect(Collectors.toList()));</span><br><span class="line"></span><br><span class="line">            List&lt;LifecycleComponent&gt; pluginLifecycleComponents = <span class="keyword">new</span> ArrayList&lt;&gt;(pluginsService.getGuiceServiceClasses().stream()</span><br><span class="line">                .map(injector::getInstance).collect(Collectors.toList()));</span><br><span class="line">            resourcesToClose.addAll(pluginLifecycleComponents);</span><br><span class="line">            <span class="comment">// 开始</span></span><br><span class="line">            transportService.start();</span><br><span class="line">            transportService.acceptIncomingRequests();</span><br><span class="line">            <span class="comment">// 创建ClientTemplate实例</span></span><br><span class="line">            ClientTemplate transportClient = <span class="keyword">new</span> ClientTemplate(injector, pluginLifecycleComponents, nodesService, proxy, namedWriteableRegistry);</span><br><span class="line">            resourcesToClose.clear();</span><br><span class="line">            <span class="comment">// 返回ClientTemplate实例</span></span><br><span class="line">            <span class="keyword">return</span> transportClient;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            IOUtils.closeWhileHandlingException(resourcesToClose);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>通过上面的源码可以知道，构造函数的初始化和Node的初始化过程是非常相似的，Client的初始化只是不会初始化那么多模块信息，但是常规的ThreadPool、PluginsService、NetworkService、NetworkModule、transportService等，最终会创建一个ClientTemplate对象，然后返回，我们不会分析每一个模块的初始化过程，这里只会分析ThreadPool和transportService的过程，在后面会介绍。</p>
<h6 id="2-1-3-3-ClientTemplate-类分析"><a href="#2-1-3-3-ClientTemplate-类分析" class="headerlink" title="2.1.3.3 ClientTemplate 类分析"></a>2.1.3.3 ClientTemplate 类分析</h6><p>我们来看看ClientTemplate 类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ClientTemplate</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 依赖注入的对象,负责管理各种注入的Bean</span></span><br><span class="line">        <span class="keyword">final</span> Injector injector;</span><br><span class="line">        <span class="comment">// 插件管理：启动、停止等</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> List&lt;LifecycleComponent&gt; pluginLifecycleComponents;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> TransportClientNodesService nodesService;</span><br><span class="line">        <span class="comment">// Transport代理</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> TransportProxyClient proxy;</span><br><span class="line">        <span class="comment">// 暂时不清楚</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> NamedWriteableRegistry namedWriteableRegistry;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="title">ClientTemplate</span><span class="params">(Injector injector, List&lt;LifecycleComponent&gt; pluginLifecycleComponents,</span></span></span><br><span class="line"><span class="function"><span class="params">                TransportClientNodesService nodesService, TransportProxyClient proxy, NamedWriteableRegistry namedWriteableRegistry)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.injector = injector;</span><br><span class="line">            <span class="keyword">this</span>.pluginLifecycleComponents = pluginLifecycleComponents;</span><br><span class="line">            <span class="keyword">this</span>.nodesService = nodesService;</span><br><span class="line">            <span class="keyword">this</span>.proxy = proxy;</span><br><span class="line">            <span class="keyword">this</span>.namedWriteableRegistry = namedWriteableRegistry;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">Settings <span class="title">getSettings</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> injector.getInstance(Settings.class);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">ThreadPool <span class="title">getThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> injector.getInstance(ThreadPool.class);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这个类封装了依赖注入管理类injector、插件pluginLifecycleComponents、Transport代理proxy、namedWriteableRegistry、nodesService等5个成员变量。</p>
<h6 id="2-1-3-4-nodesService初始化"><a href="#2-1-3-4-nodesService初始化" class="headerlink" title="2.1.3.4 nodesService初始化"></a>2.1.3.4 nodesService初始化</h6><p>nodesService是TransportClientNodesService：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">TransportClientNodesService(Settings settings, TransportService transportService,</span><br><span class="line">                                       ThreadPool threadPool, TransportClient.HostFailureListener hostFailureListener) &#123;</span><br><span class="line">        <span class="keyword">super</span>(settings);</span><br><span class="line">        <span class="keyword">this</span>.clusterName = ClusterName.CLUSTER_NAME_SETTING.get(settings);</span><br><span class="line">        <span class="keyword">this</span>.transportService = transportService;</span><br><span class="line">        <span class="keyword">this</span>.threadPool = threadPool;</span><br><span class="line">        <span class="keyword">this</span>.minCompatibilityVersion = Version.CURRENT.minimumCompatibilityVersion();</span><br><span class="line">        <span class="comment">// CLIENT_TRANSPORT_NODES_SAMPLER_INTERVAL参数默认5秒，在TransportClient中定义的</span></span><br><span class="line">        <span class="keyword">this</span>.nodesSamplerInterval = TransportClient.CLIENT_TRANSPORT_NODES_SAMPLER_INTERVAL.get(<span class="keyword">this</span>.settings);</span><br><span class="line">        <span class="keyword">this</span>.pingTimeout = TransportClient.CLIENT_TRANSPORT_PING_TIMEOUT.get(<span class="keyword">this</span>.settings).millis();</span><br><span class="line">        <span class="keyword">this</span>.ignoreClusterName = TransportClient.CLIENT_TRANSPORT_IGNORE_CLUSTER_NAME.get(<span class="keyword">this</span>.settings);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">            logger.debug(<span class="string">"node_sampler_interval[&#123;&#125;]"</span>, nodesSamplerInterval);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 这里判断是否启用了嗅探：这个Sniff参数就在这里使用</span></span><br><span class="line">        <span class="keyword">if</span> (TransportClient.CLIENT_TRANSPORT_SNIFF.get(<span class="keyword">this</span>.settings)) &#123;</span><br><span class="line">            <span class="keyword">this</span>.nodesSampler = <span class="keyword">new</span> SniffNodesSampler();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.nodesSampler = <span class="keyword">new</span> SimpleNodeSampler();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.hostFailureListener = hostFailureListener;</span><br><span class="line">        <span class="comment">// 创建定时任务：通过GENERIC类型的线程池处理</span></span><br><span class="line">        <span class="keyword">this</span>.nodesSamplerFuture = threadPool.schedule(nodesSamplerInterval, ThreadPool.Names.GENERIC, <span class="keyword">new</span> ScheduledNodeSampler());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这个类的构造方法很多参数都是从TransportClient中带过来的，比如是否启用嗅探参数Sniff，根据这个参数选择不同的策略SniffNodesSampler和SimpleNodeSampler。最后会有定时任务的时间间隔，线程池类型是GENERIC，默认是每隔5秒去ping其他节点。对于这两种策略：代码如下</p>
<p>SimpleNodeSampler类分析如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SimpleNodeSampler</span> <span class="keyword">extends</span> <span class="title">NodeSampler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doSample</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            HashSet&lt;DiscoveryNode&gt; newNodes = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">            HashSet&lt;DiscoveryNode&gt; newFilteredNodes = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">            <span class="keyword">for</span> (DiscoveryNode listedNode : listedNodes) &#123;</span><br><span class="line">                <span class="comment">// 通过Netty4获取connection</span></span><br><span class="line">                <span class="keyword">try</span> (Transport.Connection connection = transportService.openConnection(listedNode, LISTED_NODES_PROFILE))&#123;</span><br><span class="line">                    <span class="keyword">final</span> PlainTransportFuture&lt;LivenessResponse&gt; handler = <span class="keyword">new</span> PlainTransportFuture&lt;&gt;(</span><br><span class="line">                        <span class="keyword">new</span> FutureTransportResponseHandler&lt;LivenessResponse&gt;() &#123;</span><br><span class="line">                            <span class="meta">@Override</span></span><br><span class="line">                            <span class="function"><span class="keyword">public</span> LivenessResponse <span class="title">newInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                                <span class="keyword">return</span> <span class="keyword">new</span> LivenessResponse();</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;);</span><br><span class="line">                    <span class="comment">// 发送STATE的类型的Request：最终是调用了一个异步发送的方式</span></span><br><span class="line">                    transportService.sendRequest(connection, TransportLivenessAction.NAME, <span class="keyword">new</span> LivenessRequest(),</span><br><span class="line">                        TransportRequestOptions.builder().withType(TransportRequestOptions.Type.STATE).withTimeout(pingTimeout).build(),</span><br><span class="line">                        handler);</span><br><span class="line">                    <span class="keyword">final</span> LivenessResponse livenessResponse = handler.txGet();</span><br><span class="line">                    <span class="keyword">if</span> (!ignoreClusterName &amp;&amp; !clusterName.equals(livenessResponse.getClusterName())) &#123;</span><br><span class="line">                        logger.warn(<span class="string">"node &#123;&#125; not part of the cluster &#123;&#125;, ignoring..."</span>, listedNode, clusterName);</span><br><span class="line">                        newFilteredNodes.add(listedNode);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// use discovered information but do keep the original transport address,</span></span><br><span class="line">                        <span class="comment">// so people can control which address is exactly used.</span></span><br><span class="line">                        DiscoveryNode nodeWithInfo = livenessResponse.getDiscoveryNode();</span><br><span class="line">                        newNodes.add(<span class="keyword">new</span> DiscoveryNode(nodeWithInfo.getName(), nodeWithInfo.getId(), nodeWithInfo.getEphemeralId(),</span><br><span class="line">                            nodeWithInfo.getHostName(), nodeWithInfo.getHostAddress(), listedNode.getAddress(),</span><br><span class="line">                            nodeWithInfo.getAttributes(), nodeWithInfo.getRoles(), nodeWithInfo.getVersion()));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (ConnectTransportException e) &#123;</span><br><span class="line">                    logger.debug(</span><br><span class="line">                        (Supplier&lt;?&gt;)</span><br><span class="line">                            () -&gt; <span class="keyword">new</span> ParameterizedMessage(<span class="string">"failed to connect to node [&#123;&#125;], ignoring..."</span>, listedNode), e);</span><br><span class="line">                    hostFailureListener.onNodeDisconnected(listedNode, e);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    logger.info(</span><br><span class="line">                        (Supplier&lt;?&gt;) () -&gt; <span class="keyword">new</span> ParameterizedMessage(<span class="string">"failed to get node info for &#123;&#125;, disconnecting..."</span>, listedNode), e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">		   <span class="comment">// 验证节点</span></span><br><span class="line">            nodes = validateNewNodes(newNodes);</span><br><span class="line">            filteredNodes = Collections.unmodifiableList(<span class="keyword">new</span> ArrayList&lt;&gt;(newFilteredNodes));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//该方法主要是为每一个节点建立的连接进行检验</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> List&lt;DiscoveryNode&gt; <span class="title">validateNewNodes</span><span class="params">(Set&lt;DiscoveryNode&gt; nodes)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (Iterator&lt;DiscoveryNode&gt; it = nodes.iterator(); it.hasNext(); ) &#123;</span><br><span class="line">                DiscoveryNode node = it.next();</span><br><span class="line">                <span class="comment">// 循环的检验与每个可用节点建立的连接是否已完成</span></span><br><span class="line">                <span class="keyword">if</span> (!transportService.nodeConnected(node)) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        logger.trace(<span class="string">"connecting to node [&#123;&#125;]"</span>, node);</span><br><span class="line">                        <span class="comment">// 确定已经建立连接</span></span><br><span class="line">                        transportService.connectToNode(node);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        it.remove();</span><br><span class="line">                        logger.debug((Supplier&lt;?&gt;) () -&gt; <span class="keyword">new</span> ParameterizedMessage(<span class="string">"failed to connect to discovered node [&#123;&#125;]"</span>, node), e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 返回列表</span></span><br><span class="line">            <span class="keyword">return</span> Collections.unmodifiableList(<span class="keyword">new</span> ArrayList&lt;&gt;(nodes));</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>这个类的工作还是比较清晰的，就是获取配置的listedNodes然后去请求一个STATE类型的Request，这里的Connection是通过Netty4来拿到的，具体在后续会分析到，而线程是用GENERIC的线程池。把成功建立连接的所有的Nodes保存起来，而与每个Node也只保持1条连接。</p>
<p>我们再来看看SniffNodesSampler是什么情况：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SniffNodesSampler</span> <span class="keyword">extends</span> <span class="title">NodeSampler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doSample</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// the nodes we are going to ping include the core listed nodes that were added</span></span><br><span class="line">            <span class="comment">// and the last round of discovered nodes</span></span><br><span class="line">            <span class="comment">// 获取待ping的nodesToPing：从listedNodes和nodes获取</span></span><br><span class="line">            Set&lt;DiscoveryNode&gt; nodesToPing = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (DiscoveryNode node : listedNodes) &#123;</span><br><span class="line">                nodesToPing.add(node);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (DiscoveryNode node : nodes) &#123;</span><br><span class="line">                nodesToPing.add(node);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 设置一个计数器：大小为待ping的Node的列表nodesToPing大小</span></span><br><span class="line">            <span class="keyword">final</span> CountDownLatch latch = <span class="keyword">new</span> CountDownLatch(nodesToPing.size());</span><br><span class="line">            <span class="comment">// 将cluster响应状态存储到ConcurrentMap中：clusterStateResponses</span></span><br><span class="line">            <span class="keyword">final</span> ConcurrentMap&lt;DiscoveryNode, ClusterStateResponse&gt; clusterStateResponses = ConcurrentCollections.newConcurrentMap();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 首先也是先向所有的listedNode都ping一遍，注意这里用的是MANAGEMENT的threadPool</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">final</span> DiscoveryNode nodeToPing : nodesToPing) &#123;</span><br><span class="line">                    <span class="comment">// 通过MANAGEMENT类型的线程处理:</span></span><br><span class="line">                    threadPool.executor(ThreadPool.Names.MANAGEMENT).execute(<span class="keyword">new</span> AbstractRunnable() &#123;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">/**</span></span><br><span class="line"><span class="comment">                         * we try to reuse existing connections but if needed we will open a temporary connection</span></span><br><span class="line"><span class="comment">                         * that will be closed at the end of the execution.</span></span><br><span class="line"><span class="comment">                         */</span></span><br><span class="line">                        Transport.Connection connectionToClose = <span class="keyword">null</span>;</span><br><span class="line">                        <span class="comment">// 关闭异常</span></span><br><span class="line">                        <span class="function"><span class="keyword">void</span> <span class="title">onDone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                            <span class="keyword">try</span> &#123;</span><br><span class="line">                                IOUtils.closeWhileHandlingException(connectionToClose);</span><br><span class="line">                            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                                latch.countDown();</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 如果失败：调用 onDone()方法，同时抛出异常信息</span></span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(Exception e)</span> </span>&#123;</span><br><span class="line">                            onDone();</span><br><span class="line">                            <span class="keyword">if</span> (e <span class="keyword">instanceof</span> ConnectTransportException) &#123;</span><br><span class="line">                                logger.debug((Supplier&lt;?&gt;)</span><br><span class="line">                                    () -&gt; <span class="keyword">new</span> ParameterizedMessage(<span class="string">"failed to connect to node [&#123;&#125;], ignoring..."</span>, nodeToPing), e);</span><br><span class="line">                                hostFailureListener.onNodeDisconnected(nodeToPing, e);</span><br><span class="line">                            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                logger.info(</span><br><span class="line">                                    (Supplier&lt;?&gt;) () -&gt; <span class="keyword">new</span> ParameterizedMessage(</span><br><span class="line">                                        <span class="string">"failed to get local cluster state info for &#123;&#125;, disconnecting..."</span>, nodeToPing), e);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doRun</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                            Transport.Connection pingConnection = <span class="keyword">null</span>;</span><br><span class="line">                            <span class="keyword">if</span> (nodes.contains(nodeToPing)) &#123;</span><br><span class="line">                                <span class="keyword">try</span> &#123;</span><br><span class="line">                                    <span class="comment">// 调用TransportService发起连接：获取ping的连接</span></span><br><span class="line">                                    pingConnection = transportService.getConnection(nodeToPing);</span><br><span class="line">                                &#125; <span class="keyword">catch</span> (NodeNotConnectedException e) &#123;</span><br><span class="line">                                    <span class="comment">// will use a temp connection</span></span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">if</span> (pingConnection == <span class="keyword">null</span>) &#123;</span><br><span class="line">                                logger.trace(<span class="string">"connecting to cluster node [&#123;&#125;]"</span>, nodeToPing);</span><br><span class="line">                                <span class="comment">// 调用TransportService发起连接：这里会建立了一堆连接</span></span><br><span class="line">                                <span class="comment">// 这是因为这个列表添加了两次</span></span><br><span class="line">                                connectionToClose = transportService.openConnection(nodeToPing, LISTED_NODES_PROFILE);</span><br><span class="line">                                pingConnection = connectionToClose;</span><br><span class="line">                            &#125;</span><br><span class="line">                            transportService.sendRequest(pingConnection, ClusterStateAction.NAME,</span><br><span class="line">                                Requests.clusterStateRequest().clear().nodes(<span class="keyword">true</span>).local(<span class="keyword">true</span>),</span><br><span class="line">                                <span class="comment">// 在pingTimeout时间内写入STATE</span></span><br><span class="line">                                TransportRequestOptions.builder().withType(TransportRequestOptions.Type.STATE)</span><br><span class="line">                                    .withTimeout(pingTimeout).build(),</span><br><span class="line">                                <span class="keyword">new</span> TransportResponseHandler&lt;ClusterStateResponse&gt;() &#123;</span><br><span class="line"></span><br><span class="line">                                    <span class="meta">@Override</span></span><br><span class="line">                                    <span class="function"><span class="keyword">public</span> ClusterStateResponse <span class="title">newInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                                        <span class="keyword">return</span> <span class="keyword">new</span> ClusterStateResponse();</span><br><span class="line">                                    &#125;</span><br><span class="line"></span><br><span class="line">                                    <span class="meta">@Override</span></span><br><span class="line">                                    <span class="function"><span class="keyword">public</span> String <span class="title">executor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                                        <span class="keyword">return</span> ThreadPool.Names.SAME;</span><br><span class="line">                                    &#125;</span><br><span class="line"></span><br><span class="line">                                    <span class="meta">@Override</span></span><br><span class="line">                                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleResponse</span><span class="params">(ClusterStateResponse response)</span> </span>&#123;</span><br><span class="line">                                        <span class="comment">// 将nodeToPing拿到的clusterState添加到clusterStateResponses当中</span></span><br><span class="line">                                        clusterStateResponses.put(nodeToPing, response);</span><br><span class="line">                                        onDone();</span><br><span class="line">                                    &#125;</span><br><span class="line"></span><br><span class="line">                                    <span class="meta">@Override</span></span><br><span class="line">                                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleException</span><span class="params">(TransportException e)</span> </span>&#123;</span><br><span class="line">                                        logger.info(</span><br><span class="line">                                            (Supplier&lt;?&gt;) () -&gt; <span class="keyword">new</span> ParameterizedMessage(</span><br><span class="line">                                                <span class="string">"failed to get local cluster state for &#123;&#125;, disconnecting..."</span>, nodeToPing), e);</span><br><span class="line">                                        <span class="keyword">try</span> &#123;</span><br><span class="line">                                            hostFailureListener.onNodeDisconnected(nodeToPing, e);</span><br><span class="line">                                        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                                            onDone();</span><br><span class="line">                                        &#125;</span><br><span class="line">                                    &#125;</span><br><span class="line">                                &#125;);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;</span><br><span class="line">                latch.await();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                Thread.currentThread().interrupt();</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            HashSet&lt;DiscoveryNode&gt; newNodes = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">            HashSet&lt;DiscoveryNode&gt; newFilteredNodes = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (Map.Entry&lt;DiscoveryNode, ClusterStateResponse&gt; entry : clusterStateResponses.entrySet()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!ignoreClusterName &amp;&amp; !clusterName.equals(entry.getValue().getClusterName())) &#123;</span><br><span class="line">                    logger.warn(<span class="string">"node &#123;&#125; not part of the cluster &#123;&#125;, ignoring..."</span>,</span><br><span class="line">                            entry.getValue().getState().nodes().getLocalNode(), clusterName);</span><br><span class="line">                    newFilteredNodes.add(entry.getKey());</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span> (ObjectCursor&lt;DiscoveryNode&gt; cursor : entry.getValue().getState().nodes().getDataNodes().values()) &#123;</span><br><span class="line">                    newNodes.add(cursor.value);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">		    <span class="comment">// 同样需要检验连接</span></span><br><span class="line">            nodes = validateNewNodes(newNodes);</span><br><span class="line">            filteredNodes = Collections.unmodifiableList(<span class="keyword">new</span> ArrayList&lt;&gt;(newFilteredNodes));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>首先也是先向所有的listedNode都ping一遍，注意这里用的是<code>MANAGEMENT</code>的<code>threadPool</code>，也是调用TransportService发起连接，这里要特别注意，这种方式下其实是建立了一堆连接<code>connectionToClose = transportService.openConnection(nodeToPing, LISTED_NODES_PROFILE);</code>如每个类型多少条连接这样，所以这种模式一个Client会和一个Node保持一堆连接。回调函数都很简单，成功和失败的都归类，同时拿到了每个送回来的cluster的state保存下来`clusterStateResponses.put(nodeToPing, response)。</p>
<p>从哪里看出来是一个节点对应一堆连接呢？请思考</p>
<p>最后汇总再确认一遍所有的nodes，校验完后维护，其实这里的nodes就是整个集群的所有的nodes了，剩下的就交给那个调度器去每间隔时间去ping了。</p>
<p>至此，我们已经建立好了连接了，以后如何有什么请求，就是Client向一个node去获取一个连接或者一个类型的连接池threadpool，然后就可以发起请求了。这个过程其实就是proxy的事情。</p>
<h6 id="2-1-3-5-proxy初始化"><a href="#2-1-3-5-proxy初始化" class="headerlink" title="2.1.3.5 proxy初始化"></a>2.1.3.5 proxy初始化</h6><p>在ClientTemplate类初始化时也需要初始化proxy，它只保存两个变量nodesService和proxies，nodesService是上一步初始化好的建立了连接的对象，proxies是各种操作action的proxy的集合列表：比如index、update、search、bulk等。如果我们要去执行一个操作，最终会将proxy.execute()方法拿给nodesService.execute()执行，</p>
<p>nodesService会随机选取一个建立好连接的Node来执行操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> TransportProxyClient proxy = <span class="keyword">new</span> TransportProxyClient(settings, transportService, nodesService,actionModule.getActions().values().stream().map(x -&gt; x.getAction()).collect(Collectors.toList()));</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TransportProxyClient</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 保存nodesService</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> TransportClientNodesService nodesService;</span><br><span class="line">    <span class="comment">// 各种操作action的proxy变量：比如index、update、search、bulk等</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Action, TransportActionNodeProxy&gt; proxies;</span><br><span class="line"></span><br><span class="line">    TransportProxyClient(Settings settings, TransportService transportService,</span><br><span class="line">                                TransportClientNodesService nodesService, List&lt;GenericAction&gt; actions) &#123;</span><br><span class="line">        <span class="keyword">this</span>.nodesService = nodesService;</span><br><span class="line">        Map&lt;Action, TransportActionNodeProxy&gt; proxies = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="comment">// 循环的添加action的proxy到HashMap中</span></span><br><span class="line">        <span class="keyword">for</span> (GenericAction action : actions) &#123;</span><br><span class="line">            <span class="keyword">if</span> (action <span class="keyword">instanceof</span> Action) &#123;</span><br><span class="line">                proxies.put((Action) action, <span class="keyword">new</span> TransportActionNodeProxy(settings, action, transportService));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.proxies = unmodifiableMap(proxies);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 这个代理其实调用nodesService的execute()方法</span></span><br><span class="line">    <span class="keyword">public</span> &lt;Request extends ActionRequest, Response extends ActionResponse, RequestBuilder extends</span><br><span class="line">        ActionRequestBuilder&lt;Request, Response, RequestBuilder&gt;&gt; <span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">(<span class="keyword">final</span> Action&lt;Request, Response, RequestBuilder&gt; action,<span class="keyword">final</span> Request request, ActionListener&lt;Response&gt; listener)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> TransportActionNodeProxy&lt;Request, Response&gt; proxy = proxies.get(action);</span><br><span class="line">        nodesService.execute((n, l) -&gt; proxy.execute(n, request, l), listener);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>nodesService.execute()方法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;Response&gt; <span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">(NodeListenerCallback&lt;Response&gt; callback, ActionListener&lt;Response&gt; listener)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// we first read nodes before checking the closed state; this</span></span><br><span class="line">       <span class="comment">// is because otherwise we could be subject to a race where we</span></span><br><span class="line">       <span class="comment">// read the state as not being closed, and then the client is</span></span><br><span class="line">       <span class="comment">// closed and the nodes list is cleared, and then a</span></span><br><span class="line">       <span class="comment">// NoNodeAvailableException is thrown</span></span><br><span class="line">       <span class="comment">// it is important that the order of first setting the state of</span></span><br><span class="line">       <span class="comment">// closed and then clearing the list of nodes is maintained in</span></span><br><span class="line">       <span class="comment">// the close method</span></span><br><span class="line">       <span class="keyword">final</span> List&lt;DiscoveryNode&gt; nodes = <span class="keyword">this</span>.nodes;</span><br><span class="line">       <span class="keyword">if</span> (closed) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"transport client is closed"</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 确保Nodes可用</span></span><br><span class="line">       ensureNodesAreAvailable(nodes);</span><br><span class="line">       <span class="comment">// 随机获取</span></span><br><span class="line">       <span class="keyword">int</span> index = getNodeNumber();</span><br><span class="line">       RetryListener&lt;Response&gt; retryListener = <span class="keyword">new</span> RetryListener&lt;&gt;(callback, listener, nodes, index, hostFailureListener);</span><br><span class="line">       DiscoveryNode node = retryListener.getNode(<span class="number">0</span>);</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="comment">// 回调doWithNode</span></span><br><span class="line">           callback.doWithNode(node, retryListener);</span><br><span class="line">       &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               <span class="comment">//this exception can't come from the TransportService as it doesn't throw exception at all</span></span><br><span class="line">               listener.onFailure(e);</span><br><span class="line">           &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">               retryListener.maybeNodeFailed(node, e);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 随机选取一个Node</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getNodeNumber</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> index = randomNodeGenerator.incrementAndGet();</span><br><span class="line">       <span class="keyword">if</span> (index &lt; <span class="number">0</span>) &#123;</span><br><span class="line">           index = <span class="number">0</span>;</span><br><span class="line">           randomNodeGenerator.set(<span class="number">0</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> index;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-2-RestClient初始化"><a href="#2-2-RestClient初始化" class="headerlink" title="2.2 RestClient初始化"></a>2.2 RestClient初始化</h4><p>这个类初始化非常简单，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RestClient</span> <span class="keyword">implements</span> <span class="title">Closeable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Log logger = LogFactory.getLog(RestClient.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CloseableHttpAsyncClient client;</span><br><span class="line">    <span class="comment">//we don't rely on default headers supported by HttpAsyncClient as those cannot be replaced</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Header[] defaultHeaders;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> maxRetryTimeoutMillis;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String pathPrefix;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger lastHostIndex = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> HostTuple&lt;Set&lt;HttpHost&gt;&gt; hostTuple;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ConcurrentMap&lt;HttpHost, DeadHostState&gt; blacklist = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> FailureListener failureListener;</span><br><span class="line"></span><br><span class="line">    RestClient(CloseableHttpAsyncClient client, <span class="keyword">long</span> maxRetryTimeoutMillis, Header[] defaultHeaders,</span><br><span class="line">               HttpHost[] hosts, String pathPrefix, FailureListener failureListener) &#123;</span><br><span class="line">        <span class="keyword">this</span>.client = client;</span><br><span class="line">        <span class="keyword">this</span>.maxRetryTimeoutMillis = maxRetryTimeoutMillis;</span><br><span class="line">        <span class="keyword">this</span>.defaultHeaders = defaultHeaders;</span><br><span class="line">        <span class="keyword">this</span>.failureListener = failureListener;</span><br><span class="line">        <span class="keyword">this</span>.pathPrefix = pathPrefix;</span><br><span class="line">        setHosts(hosts);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns a new &#123;<span class="doctag">@link</span> RestClientBuilder&#125; to help with &#123;<span class="doctag">@link</span> RestClient&#125; creation.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RestClientBuilder <span class="title">builder</span><span class="params">(HttpHost... hosts)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RestClientBuilder(hosts);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Replaces the hosts that the client communicates with.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> HttpHost</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">setHosts</span><span class="params">(HttpHost... hosts)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (hosts == <span class="keyword">null</span> || hosts.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"hosts must not be null nor empty"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Set&lt;HttpHost&gt; httpHosts = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        AuthCache authCache = <span class="keyword">new</span> BasicAuthCache();</span><br><span class="line">        <span class="keyword">for</span> (HttpHost host : hosts) &#123;</span><br><span class="line">            Objects.requireNonNull(host, <span class="string">"host cannot be null"</span>);</span><br><span class="line">            httpHosts.add(host);</span><br><span class="line">            authCache.put(host, <span class="keyword">new</span> BasicScheme());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.hostTuple = <span class="keyword">new</span> HostTuple&lt;&gt;(Collections.unmodifiableSet(httpHosts), authCache);</span><br><span class="line">        <span class="keyword">this</span>.blacklist.clear();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这里不像TransportClient可以启用嗅探功能，仅仅只是会维护你明确配置的所有host，如果有必要，则把认证信息authCache缓存起来而已，剩下的事情就是交给httpClient调用。</p>
<p>对比这两种客户端的初始化，TransportClient稍微复杂一些，RestClient相对简单，它是最后是将所有的调用交给Apache的HttpClient客户端去完成。</p>
<p>至此，我们Client的源码流程大致分析完成，但是TransportClient还有一个问题，底层的通信是怎么样的？我们紧接着分析Transport源码来解答这一疑问。</p>
<p>buildTemplate()方法中有这么一段代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Transport transport = networkModule.getTransportSupplier().get();</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 初始化TransportService</span></span><br><span class="line">            <span class="keyword">final</span> TransportService transportService = <span class="keyword">new</span> TransportService(settings, transport, threadPool,</span><br><span class="line">                networkModule.getTransportInterceptor(),</span><br><span class="line">                boundTransportAddress -&gt; DiscoveryNode.createLocal(settings, address, UUIDs.randomBase64UUID()), <span class="keyword">null</span>);</span><br></pre></td></tr></table></figure>
<p>这段代码就说明，节点间通信都是需要构造Transport实例，然后传递到TransportService当中来进行的。</p>
<h4 id="2-3-Transport源码分析"><a href="#2-3-Transport源码分析" class="headerlink" title="2.3 Transport源码分析"></a>2.3 Transport源码分析</h4><p>我们知道这个Transport是用来进行节点之间通信的核心类。无论是无论是集群状态信息，还是搜索索引请求信息，都是通过transport传送。transport实现一般有LocalTransport和NettyTransport两种，在NetworkModule中注册中可以通过node是local还是network的来判别使用哪一种transport，可以通过配置<code>transport.type</code>来决定。</p>
<p><img src="F:\hexo\source\images\es\Transport实现类.png" alt=":\hexo\source\images\es\Transport实现类.pn"></p>
<h5 id="2-3-1-TransportClient调用流程"><a href="#2-3-1-TransportClient调用流程" class="headerlink" title="2.3.1 TransportClient调用流程"></a>2.3.1 TransportClient调用流程</h5><p>通过transportService.start()方法，最终会进入到doStart()方法中，这个流程可以参考源码启动章节</p>
<p>我们来看看doStart()方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doStart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        adapter.rxMetric.clear();</span><br><span class="line">        adapter.txMetric.clear();</span><br><span class="line">        transport.transportServiceAdapter(adapter);</span><br><span class="line">        <span class="comment">// 调用父类的start()方法</span></span><br><span class="line">        transport.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (transport.boundAddress() != <span class="keyword">null</span> &amp;&amp; logger.isInfoEnabled()) &#123;</span><br><span class="line">            logger.info(<span class="string">"&#123;&#125;"</span>, transport.boundAddress());</span><br><span class="line">            <span class="keyword">for</span> (Map.Entry&lt;String, BoundTransportAddress&gt; entry : transport.profileBoundAddresses().entrySet()) &#123;</span><br><span class="line">                logger.info(<span class="string">"profile [&#123;&#125;]: &#123;&#125;"</span>, entry.getKey(), entry.getValue());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 获取节点</span></span><br><span class="line">        localNode = localNodeFactory.apply(transport.boundAddress());</span><br><span class="line">        <span class="comment">// 注册到injection中：这里的线程类型是SAME</span></span><br><span class="line">        registerRequestHandler(</span><br><span class="line">            HANDSHAKE_ACTION_NAME,</span><br><span class="line">            () -&gt; HandshakeRequest.INSTANCE,</span><br><span class="line">            ThreadPool.Names.SAME,</span><br><span class="line">            <span class="keyword">false</span>, <span class="keyword">false</span>,</span><br><span class="line">            (request, channel) -&gt; channel.sendResponse(</span><br><span class="line">                    <span class="keyword">new</span> HandshakeResponse(localNode, clusterName, localNode.getVersion())));</span><br><span class="line">        <span class="keyword">if</span> (connectToRemoteCluster) &#123;</span><br><span class="line">            <span class="comment">// here we start to connect to the remote clusters</span></span><br><span class="line">            remoteClusterService.initializeRemoteClusters();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>NettyTransport.doStart()方法：这个方法创建了Netty的一个客户端ClientBootstrap和一个服务器ServerBootstrap，因为节点之间要进行通信，所以这个节点既是客户端也是服务端。默认情况下客户端和服务端都会启动。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doStart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> success = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 创建一个clientBootstrap</span></span><br><span class="line">            bootstrap = createBootstrap();</span><br><span class="line">            <span class="keyword">if</span> (NetworkService.NETWORK_SERVER.get(settings)) &#123;</span><br><span class="line">                <span class="keyword">final</span> Netty4OpenChannelsHandler openChannels = <span class="keyword">new</span> Netty4OpenChannelsHandler(logger);</span><br><span class="line">                <span class="keyword">this</span>.serverOpenChannels = openChannels;</span><br><span class="line">                <span class="comment">// loop through all profiles and start them up, special handling for default one</span></span><br><span class="line">                <span class="keyword">for</span> (Map.Entry&lt;String, Settings&gt; entry : buildProfileSettings().entrySet()) &#123;</span><br><span class="line">                    <span class="comment">// merge fallback settings with default settings with profile settings so we have complete settings with default values</span></span><br><span class="line">                    <span class="keyword">final</span> Settings settings = Settings.builder()</span><br><span class="line">                        .put(createFallbackSettings())</span><br><span class="line">                        .put(entry.getValue()).build();</span><br><span class="line">                    <span class="comment">// 创建一个ServerBootstrap</span></span><br><span class="line">                    createServerBootstrap(entry.getKey(), settings);</span><br><span class="line">                    bindServer(entry.getKey(), settings);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 调用TCPTransport的doStart()方法创建一个GENERIC类型的线程池</span></span><br><span class="line">            <span class="keyword">super</span>.doStart();</span><br><span class="line">            success = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (success == <span class="keyword">false</span>) &#123;</span><br><span class="line">                doStop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>在transportService.dosStart()方法当中，会调用transport.start()，最终会调用NettyTransport.doStart()方法。</p>
<p>通过上面的分析，我们就可以知道，最终transport service中的transport实例落到了transport 模块上。transport模块分为local transport 和 netty transport。这里我们只看netty transport。</p>
<p>其他的流程跟这个大致相同，就不再分析了。</p>
<p>我们来分析一下这个NettyTransport类：</p>
<h5 id="2-3-2-Netty4Transport"><a href="#2-3-2-Netty4Transport" class="headerlink" title="2.3.2 Netty4Transport"></a>2.3.2 Netty4Transport</h5><p>分析这个类，我们要带着几个问题去看：</p>
<ul>
<li>怎么启动一个服务？</li>
<li>怎么去发送数据？</li>
<li>怎么接收数据？</li>
</ul>
<h6 id="2-3-2-1-类图"><a href="#2-3-2-1-类图" class="headerlink" title="2.3.2.1 类图"></a>2.3.2.1 类图</h6><p><img src="F:\hexo\source\images\es\Netty4Transport类图.png" alt=":\hexo\source\images\es\Netty4Transport类图.pn"></p>
<p>我们可以看到Netty4Transport继承了TcpTransport。</p>
<h6 id="2-3-2-2-配置信息"><a href="#2-3-2-2-配置信息" class="headerlink" title="2.3.2.2 配置信息"></a>2.3.2.2 配置信息</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// workerCount表示transport的总共的worker数目，由transport.netty.worker_count来配置</span></span><br><span class="line">    <span class="comment">// 默认值是32和Runtime.getRuntime().availableProcessors()中的最小值，也就是不能超过32</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Setting&lt;Integer&gt; WORKER_COUNT =</span><br><span class="line">        <span class="keyword">new</span> Setting&lt;&gt;(<span class="string">"transport.netty.worker_count"</span>,</span><br><span class="line">            (s) -&gt; Integer.toString(EsExecutors.boundedNumberOfProcessors(s) * <span class="number">2</span>),</span><br><span class="line">            (s) -&gt; Setting.parseInt(s, <span class="number">1</span>, <span class="string">"transport.netty.worker_count"</span>), Property.NodeScope, Property.Shared);</span><br><span class="line">    <span class="comment">// 最大</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Setting&lt;ByteSizeValue&gt; NETTY_MAX_CUMULATION_BUFFER_CAPACITY =</span><br><span class="line">        Setting.byteSizeSetting(</span><br><span class="line">                <span class="string">"transport.netty.max_cumulation_buffer_capacity"</span>,</span><br><span class="line">                <span class="keyword">new</span> ByteSizeValue(-<span class="number">1</span>),</span><br><span class="line">                Property.NodeScope,</span><br><span class="line">                Property.Shared);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Setting&lt;Integer&gt; NETTY_MAX_COMPOSITE_BUFFER_COMPONENTS =</span><br><span class="line">        Setting.intSetting(<span class="string">"transport.netty.max_composite_buffer_components"</span>, -<span class="number">1</span>, -<span class="number">1</span>, Property.NodeScope, Property.Shared);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Setting&lt;ByteSizeValue&gt; NETTY_RECEIVE_PREDICTOR_SIZE = Setting.byteSizeSetting(</span><br><span class="line">            <span class="string">"transport.netty.receive_predictor_size"</span>, <span class="keyword">new</span> ByteSizeValue(<span class="number">64</span>, ByteSizeUnit.KB), Property.NodeScope, Property.Shared);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Setting&lt;ByteSizeValue&gt; NETTY_RECEIVE_PREDICTOR_MIN =</span><br><span class="line">        byteSizeSetting(<span class="string">"transport.netty.receive_predictor_min"</span>, NETTY_RECEIVE_PREDICTOR_SIZE, Property.NodeScope, Property.Shared);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Setting&lt;ByteSizeValue&gt; NETTY_RECEIVE_PREDICTOR_MAX =</span><br><span class="line">        byteSizeSetting(<span class="string">"transport.netty.receive_predictor_max"</span>, NETTY_RECEIVE_PREDICTOR_SIZE, Property.NodeScope, Property.Shared);</span><br><span class="line">    <span class="comment">// Netty的boss线程池大小</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Setting&lt;Integer&gt; NETTY_BOSS_COUNT =</span><br><span class="line">        intSetting(<span class="string">"transport.netty.boss_count"</span>, <span class="number">1</span>, <span class="number">1</span>, Property.NodeScope, Property.Shared);</span><br></pre></td></tr></table></figure>
<h6 id="2-3-2-3-启动服务"><a href="#2-3-2-3-启动服务" class="headerlink" title="2.3.2.3 启动服务"></a>2.3.2.3 启动服务</h6><p>其实在TransportClient的调用流程中已经说明了怎么去启动一个Netty服务。主要是通过下面的这句话来启动：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">transportService.start();</span><br></pre></td></tr></table></figure>
<p>最终会调用到Netty4Transport的doStart()方法，在改方法中创建clientBootstrap和serverBootstrap.</p>
<p>客户端代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Bootstrap <span class="title">createBootstrap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Bootstrap bootstrap = <span class="keyword">new</span> Bootstrap();</span><br><span class="line">        <span class="keyword">if</span> (TCP_BLOCKING_CLIENT.get(settings)) &#123;</span><br><span class="line">            bootstrap.group(<span class="keyword">new</span> OioEventLoopGroup(<span class="number">1</span>, daemonThreadFactory(settings, TRANSPORT_CLIENT_WORKER_THREAD_NAME_PREFIX)));</span><br><span class="line">            bootstrap.channel(OioSocketChannel.class);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            bootstrap.group(<span class="keyword">new</span> NioEventLoopGroup(workerCount, daemonThreadFactory(settings, TRANSPORT_CLIENT_BOSS_THREAD_NAME_PREFIX)));</span><br><span class="line">            bootstrap.channel(NioSocketChannel.class);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        bootstrap.handler(getClientChannelInitializer());</span><br><span class="line"></span><br><span class="line">        bootstrap.option(ChannelOption.CONNECT_TIMEOUT_MILLIS, Math.toIntExact(defaultConnectionProfile.getConnectTimeout().millis()));</span><br><span class="line">        bootstrap.option(ChannelOption.TCP_NODELAY, TCP_NO_DELAY.get(settings));</span><br><span class="line">        bootstrap.option(ChannelOption.SO_KEEPALIVE, TCP_KEEP_ALIVE.get(settings));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> ByteSizeValue tcpSendBufferSize = TCP_SEND_BUFFER_SIZE.get(settings);</span><br><span class="line">        <span class="keyword">if</span> (tcpSendBufferSize.getBytes() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            bootstrap.option(ChannelOption.SO_SNDBUF, Math.toIntExact(tcpSendBufferSize.getBytes()));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> ByteSizeValue tcpReceiveBufferSize = TCP_RECEIVE_BUFFER_SIZE.get(settings);</span><br><span class="line">        <span class="keyword">if</span> (tcpReceiveBufferSize.getBytes() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            bootstrap.option(ChannelOption.SO_RCVBUF, Math.toIntExact(tcpReceiveBufferSize.getBytes()));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        bootstrap.option(ChannelOption.RCVBUF_ALLOCATOR, recvByteBufAllocator);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> reuseAddress = TCP_REUSE_ADDRESS.get(settings);</span><br><span class="line">        bootstrap.option(ChannelOption.SO_REUSEADDR, reuseAddress);</span><br><span class="line"></span><br><span class="line">        bootstrap.validate();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> bootstrap;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>服务端代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">createServerBootstrap</span><span class="params">(String name, Settings settings)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">            logger.debug(<span class="string">"using profile[&#123;&#125;], worker_count[&#123;&#125;], port[&#123;&#125;], bind_host[&#123;&#125;], publish_host[&#123;&#125;], compress[&#123;&#125;], "</span></span><br><span class="line">                    + <span class="string">"connect_timeout[&#123;&#125;], connections_per_node[&#123;&#125;/&#123;&#125;/&#123;&#125;/&#123;&#125;/&#123;&#125;], receive_predictor[&#123;&#125;-&gt;&#123;&#125;]"</span>,</span><br><span class="line">                name, workerCount, settings.get(<span class="string">"port"</span>), settings.get(<span class="string">"bind_host"</span>), settings.get(<span class="string">"publish_host"</span>), compress,</span><br><span class="line">                defaultConnectionProfile.getConnectTimeout(),</span><br><span class="line">                defaultConnectionProfile.getNumConnectionsPerType(TransportRequestOptions.Type.RECOVERY),</span><br><span class="line">                defaultConnectionProfile.getNumConnectionsPerType(TransportRequestOptions.Type.BULK),</span><br><span class="line">                defaultConnectionProfile.getNumConnectionsPerType(TransportRequestOptions.Type.REG),</span><br><span class="line">                defaultConnectionProfile.getNumConnectionsPerType(TransportRequestOptions.Type.STATE),</span><br><span class="line">                defaultConnectionProfile.getNumConnectionsPerType(TransportRequestOptions.Type.PING),</span><br><span class="line">                receivePredictorMin, receivePredictorMax);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> ThreadFactory workerFactory = daemonThreadFactory(<span class="keyword">this</span>.settings, TRANSPORT_SERVER_WORKER_THREAD_NAME_PREFIX, name);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> ServerBootstrap serverBootstrap = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (TCP_BLOCKING_SERVER.get(settings)) &#123;</span><br><span class="line">            serverBootstrap.group(<span class="keyword">new</span> OioEventLoopGroup(workerCount, workerFactory));</span><br><span class="line">            serverBootstrap.channel(OioServerSocketChannel.class);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            serverBootstrap.group(<span class="keyword">new</span> NioEventLoopGroup(workerCount, workerFactory));</span><br><span class="line">            serverBootstrap.channel(NioServerSocketChannel.class);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        serverBootstrap.childHandler(getServerChannelInitializer(name, settings));</span><br><span class="line"></span><br><span class="line">        serverBootstrap.childOption(ChannelOption.TCP_NODELAY, TCP_NO_DELAY.get(settings));</span><br><span class="line">        serverBootstrap.childOption(ChannelOption.SO_KEEPALIVE, TCP_KEEP_ALIVE.get(settings));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> ByteSizeValue tcpSendBufferSize = TCP_SEND_BUFFER_SIZE.getDefault(settings);</span><br><span class="line">        <span class="keyword">if</span> (tcpSendBufferSize != <span class="keyword">null</span> &amp;&amp; tcpSendBufferSize.getBytes() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            serverBootstrap.childOption(ChannelOption.SO_SNDBUF, Math.toIntExact(tcpSendBufferSize.getBytes()));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> ByteSizeValue tcpReceiveBufferSize = TCP_RECEIVE_BUFFER_SIZE.getDefault(settings);</span><br><span class="line">        <span class="keyword">if</span> (tcpReceiveBufferSize != <span class="keyword">null</span> &amp;&amp; tcpReceiveBufferSize.getBytes() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            serverBootstrap.childOption(ChannelOption.SO_RCVBUF, Math.toIntExact(tcpReceiveBufferSize.bytesAsInt()));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        serverBootstrap.option(ChannelOption.RCVBUF_ALLOCATOR, recvByteBufAllocator);</span><br><span class="line">        serverBootstrap.childOption(ChannelOption.RCVBUF_ALLOCATOR, recvByteBufAllocator);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> reuseAddress = TCP_REUSE_ADDRESS.get(settings);</span><br><span class="line">        serverBootstrap.option(ChannelOption.SO_REUSEADDR, reuseAddress);</span><br><span class="line">        serverBootstrap.childOption(ChannelOption.SO_REUSEADDR, reuseAddress);</span><br><span class="line"></span><br><span class="line">        serverBootstrap.validate();</span><br><span class="line"></span><br><span class="line">        serverBootstraps.put(name, serverBootstrap);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h6 id="2-3-2-4-连接服务"><a href="#2-3-2-4-连接服务" class="headerlink" title="2.3.2.4 连接服务"></a>2.3.2.4 连接服务</h6><p>我们以UnicastZenPing的连接为例：</p>
<p>在Discovery启动以后，会发现新的节点，如果发现有新节点加入，则会在UnicastZenPing调用transportService.openConnection(node, connectionProfile)方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Transport.<span class="function">Connection <span class="title">openConnection</span><span class="params">(<span class="keyword">final</span> DiscoveryNode node, ConnectionProfile profile)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (isLocalNode(node)) &#123;</span><br><span class="line">           <span class="keyword">return</span> localNodeConnection;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="keyword">return</span> transport.openConnection(node, profile);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>最终调用TcpTransport的openConnection方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> NodeChannels <span class="title">openConnection</span><span class="params">(DiscoveryNode node, ConnectionProfile connectionProfile)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConnectTransportException(<span class="keyword">null</span>, <span class="string">"can't open connection to a null node"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">boolean</span> success = <span class="keyword">false</span>;</span><br><span class="line">        NodeChannels nodeChannels = <span class="keyword">null</span>;</span><br><span class="line">        connectionProfile = resolveConnectionProfile(connectionProfile, defaultConnectionProfile);</span><br><span class="line">        globalLock.readLock().lock(); <span class="comment">// ensure we don't open connections while we are closing</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ensureOpen();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                AtomicBoolean runOnce = <span class="keyword">new</span> AtomicBoolean(<span class="keyword">false</span>);</span><br><span class="line">                Consumer&lt;Channel&gt; onClose = c -&gt; &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">// we can't assert that the channel is closed here since netty3 has a different behavior that doesn't</span></span><br><span class="line">                        <span class="comment">// consider a channel closed while it's close future is running.</span></span><br><span class="line">                        onChannelClosed(c);</span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                        <span class="comment">// we only need to disconnect from the nodes once since all other channels</span></span><br><span class="line">                        <span class="comment">// will also try to run this we protect it from running multiple times.</span></span><br><span class="line">                        <span class="keyword">if</span> (runOnce.compareAndSet(<span class="keyword">false</span>, <span class="keyword">true</span>)) &#123;</span><br><span class="line">                            disconnectFromNodeChannel(c, <span class="string">"channel closed"</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;;</span><br><span class="line">                <span class="comment">// 获取连接的Channel</span></span><br><span class="line">                nodeChannels = connectToChannels(node, connectionProfile, onClose);</span><br><span class="line">                <span class="keyword">final</span> Channel channel = nodeChannels.getChannels().get(<span class="number">0</span>); <span class="comment">// one channel is guaranteed by the connection profile</span></span><br><span class="line">                <span class="keyword">final</span> TimeValue connectTimeout = connectionProfile.getConnectTimeout() == <span class="keyword">null</span> ?</span><br><span class="line">                    defaultConnectionProfile.getConnectTimeout() :</span><br><span class="line">                    connectionProfile.getConnectTimeout();</span><br><span class="line">                <span class="keyword">final</span> TimeValue handshakeTimeout = connectionProfile.getHandshakeTimeout() == <span class="keyword">null</span> ?</span><br><span class="line">                    connectTimeout : connectionProfile.getHandshakeTimeout();</span><br><span class="line">                <span class="comment">// 处理数据</span></span><br><span class="line">                <span class="keyword">final</span> Version version = executeHandshake(node, channel, handshakeTimeout);</span><br><span class="line">                <span class="keyword">if</span> (version != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// if we are talking to a pre 5.2 node we won't be able to retrieve the version since it doesn't implement the handshake</span></span><br><span class="line">                    <span class="comment">// we do since 5.2 - in this case we just go with the version provided by the node.</span></span><br><span class="line">                    nodeChannels = <span class="keyword">new</span> NodeChannels(nodeChannels, version); <span class="comment">// clone the channels - we now have the correct version</span></span><br><span class="line">                &#125;</span><br><span class="line">                transportServiceAdapter.onConnectionOpened(nodeChannels);</span><br><span class="line">                openConnections.add(nodeChannels);</span><br><span class="line">                success = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">return</span> nodeChannels;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ConnectTransportException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> e;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="comment">// ConnectTransportExceptions are handled specifically on the caller end - we wrap the actual exception to ensure</span></span><br><span class="line">                <span class="comment">// only relevant exceptions are logged on the caller end.. this is the same as in connectToNode</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ConnectTransportException(node, <span class="string">"general node connection failure"</span>, e);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (success == <span class="keyword">false</span>) &#123;</span><br><span class="line">                        IOUtils.closeWhileHandlingException(nodeChannels);</span><br><span class="line">                    &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            globalLock.readLock().unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>实质就是创建Netty中的Channel，一个连接就是第一个Channel，根据之前所说的会有多个类型的连接会创。</p>
<h6 id="2-3-2-5-发送数据"><a href="#2-3-2-5-发送数据" class="headerlink" title="2.3.2.5 发送数据"></a>2.3.2.5 发送数据</h6><p>先了解发送类型：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">RECOVERY：做数据恢复recovery，默认个数2个；</span><br><span class="line">BULK：做数据恢复recovery，默认个数2个；</span><br><span class="line">REG：典型的搜索和单doc索引，默认个数6个</span><br><span class="line">STATE：如集群state的发送等，默认个数1个</span><br><span class="line">PING：是node之间的ping。默认个数1个</span><br></pre></td></tr></table></figure>
<p>怎么获取Channel？在TransportService的sendRequest方法会传入一个参数options，是TransportRequestOptions的实例，包含三个属性：timeout(超时时间)、compress(是否压缩)、type(发送的类型，即上面说的五个之一)，根据需要发送数据的节点和发送的类型（上面五大类型）获得到对应的channel，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">public</span> <span class="keyword">final</span> &lt;T extends TransportResponse&gt; <span class="function"><span class="keyword">void</span> <span class="title">sendRequest</span><span class="params">(<span class="keyword">final</span> Transport.Connection connection, <span class="keyword">final</span> String action,<span class="keyword">final</span> TransportRequest request,<span class="keyword">final</span> TransportRequestOptions options,TransportResponseHandler&lt;T&gt; handler)</span> </span>&#123;</span><br><span class="line">        asyncSender.sendRequest(connection, action, request, options, handler);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.asyncSender = interceptor.interceptSender(<span class="keyword">this</span>::sendRequestInternal);</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> &lt;T extends TransportResponse&gt; <span class="function"><span class="keyword">void</span> <span class="title">sendRequestInternal</span><span class="params">(<span class="keyword">final</span> Transport.Connection connection, <span class="keyword">final</span> String action,<span class="keyword">final</span> TransportRequest request,<span class="keyword">final</span> TransportRequestOptions options,TransportResponseHandler&lt;T&gt; handler)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (connection == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"can't send request to a null connection"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        DiscoveryNode node = connection.getNode();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> requestId = transport.newRequestId();</span><br><span class="line">        <span class="keyword">final</span> TimeoutHandler timeoutHandler;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (options.timeout() == <span class="keyword">null</span>) &#123;</span><br><span class="line">                timeoutHandler = <span class="keyword">null</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                timeoutHandler = <span class="keyword">new</span> TimeoutHandler(requestId);</span><br><span class="line">            &#125;</span><br><span class="line">            Supplier&lt;ThreadContext.StoredContext&gt; storedContextSupplier = threadPool.getThreadContext().newRestorableContext(<span class="keyword">true</span>);</span><br><span class="line">            TransportResponseHandler&lt;T&gt; responseHandler = <span class="keyword">new</span> ContextRestoreResponseHandler&lt;&gt;(storedContextSupplier, handler);</span><br><span class="line">            clientHandlers.put(requestId, <span class="keyword">new</span> RequestHolder&lt;&gt;(responseHandler, connection, action, timeoutHandler));</span><br><span class="line">            <span class="keyword">if</span> (lifecycle.stoppedOrClosed()) &#123;</span><br><span class="line">                <span class="comment">// if we are not started the exception handling will remove the RequestHolder again and calls the handler to notify</span></span><br><span class="line">                <span class="comment">// the caller. It will only notify if the toStop code hasn't done the work yet.</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> TransportException(<span class="string">"TransportService is closed stopped can't send request"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (timeoutHandler != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">assert</span> options.timeout() != <span class="keyword">null</span>;</span><br><span class="line">                timeoutHandler.future = threadPool.schedule(options.timeout(), ThreadPool.Names.GENERIC, timeoutHandler);</span><br><span class="line">            &#125;</span><br><span class="line">            connection.sendRequest(requestId, action, request, options); <span class="comment">// local node optimization happens upstream</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> Exception e) &#123;</span><br><span class="line">            <span class="comment">// usually happen either because we failed to connect to the node</span></span><br><span class="line">            <span class="comment">// or because we failed serializing the message</span></span><br><span class="line">            <span class="keyword">final</span> RequestHolder holderToNotify = clientHandlers.remove(requestId);</span><br><span class="line">            <span class="comment">// If holderToNotify == null then handler has already been taken care of.</span></span><br><span class="line">            <span class="keyword">if</span> (holderToNotify != <span class="keyword">null</span>) &#123;</span><br><span class="line">                holderToNotify.cancelTimeout();</span><br><span class="line">                <span class="comment">// callback that an exception happened, but on a different thread since we don't</span></span><br><span class="line">                <span class="comment">// want handlers to worry about stack overflows</span></span><br><span class="line">                <span class="keyword">final</span> SendRequestTransportException sendRequestException = <span class="keyword">new</span> SendRequestTransportException(node, action, e);</span><br><span class="line">                threadPool.executor(ThreadPool.Names.GENERIC).execute(<span class="keyword">new</span> AbstractRunnable() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onRejection</span><span class="params">(Exception e)</span> </span>&#123;</span><br><span class="line">                        <span class="comment">// if we get rejected during node shutdown we don't wanna bubble it up</span></span><br><span class="line">                        logger.debug(</span><br><span class="line">                            (Supplier&lt;?&gt;) () -&gt; <span class="keyword">new</span> ParameterizedMessage(</span><br><span class="line">                                <span class="string">"failed to notify response handler on rejection, action: &#123;&#125;"</span>,</span><br><span class="line">                                holderToNotify.action()),</span><br><span class="line">                            e);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(Exception e)</span> </span>&#123;</span><br><span class="line">                        logger.warn(</span><br><span class="line">                            (Supplier&lt;?&gt;) () -&gt; <span class="keyword">new</span> ParameterizedMessage(</span><br><span class="line">                                <span class="string">"failed to notify response handler on exception, action: &#123;&#125;"</span>,</span><br><span class="line">                                holderToNotify.action()),</span><br><span class="line">                            e);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doRun</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                        holderToNotify.handler().handleException(sendRequestException);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                logger.debug(<span class="string">"Exception while sending request, handler likely already notified due to timeout"</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h6 id="2-3-2-6-数据写入"><a href="#2-3-2-6-数据写入" class="headerlink" title="2.3.2.6 数据写入"></a>2.3.2.6 数据写入</h6><p>之后数据该压缩的压缩（压缩方法在CompressorFactory中实现），并写入version和action；</p>
<p>在openConnection方法中，通过调用executeHandshake()方法处理数据</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Version version = executeHandshake(node, channel, handshakeTimeout);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Version <span class="title">executeHandshake</span><span class="params">(DiscoveryNode node, Channel channel, TimeValue timeout)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">        numHandshakes.inc();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> requestId = newRequestId();</span><br><span class="line">        <span class="keyword">final</span> HandshakeResponseHandler handler = <span class="keyword">new</span> HandshakeResponseHandler(channel);</span><br><span class="line">        AtomicReference&lt;Version&gt; versionRef = handler.versionRef;</span><br><span class="line">        AtomicReference&lt;Exception&gt; exceptionRef = handler.exceptionRef;</span><br><span class="line">        pendingHandshakes.put(requestId, handler);</span><br><span class="line">        <span class="keyword">boolean</span> success = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (isOpen(channel) == <span class="keyword">false</span>) &#123;</span><br><span class="line">                <span class="comment">// we have to protect us here since sendRequestToChannel won't barf if the channel is closed.</span></span><br><span class="line">                <span class="comment">// it's weird but to change it will cause a lot of impact on the exception handling code all over the codebase.</span></span><br><span class="line">                <span class="comment">// yet, if we don't check the state here we might have registered a pending handshake handler but the close</span></span><br><span class="line">                <span class="comment">// listener calling #onChannelClosed might have already run and we are waiting on the latch below unitl we time out.</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"handshake failed, channel already closed"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// for the request we use the minCompatVersion since we don't know what's the version of the node we talk to</span></span><br><span class="line">            <span class="comment">// we also have no payload on the request but the response will contain the actual version of the node we talk</span></span><br><span class="line">            <span class="comment">// to as the payload.</span></span><br><span class="line">            <span class="keyword">final</span> Version minCompatVersion = getCurrentVersion().minimumCompatibilityVersion();</span><br><span class="line">            <span class="comment">// 调用该方法发送数据</span></span><br><span class="line">            sendRequestToChannel(node, channel, requestId, HANDSHAKE_ACTION_NAME, TransportRequest.Empty.INSTANCE,</span><br><span class="line">                TransportRequestOptions.EMPTY, minCompatVersion, TransportStatus.setHandshake((<span class="keyword">byte</span>)<span class="number">0</span>));</span><br><span class="line">            <span class="keyword">if</span> (handler.latch.await(timeout.millis(), TimeUnit.MILLISECONDS) == <span class="keyword">false</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ConnectTransportException(node, <span class="string">"handshake_timeout["</span> + timeout + <span class="string">"]"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            success = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (handler.handshakeNotSupported.get()) &#123;</span><br><span class="line">                <span class="comment">// this is a BWC layer, if we talk to a pre 5.2 node then the handshake is not supported</span></span><br><span class="line">                <span class="comment">// this will go away in master once it's all ported to 5.2 but for now we keep this to make</span></span><br><span class="line">                <span class="comment">// the backport straight forward</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (exceptionRef.get() != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"handshake failed"</span>, exceptionRef.get());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                Version version = versionRef.get();</span><br><span class="line">                <span class="keyword">if</span> (getCurrentVersion().isCompatible(version) == <span class="keyword">false</span>) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Received message from unsupported version: ["</span> + version</span><br><span class="line">                        + <span class="string">"] minimal compatible version is: ["</span> + getCurrentVersion().minimumCompatibilityVersion() + <span class="string">"]"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> version;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> TransportResponseHandler&lt;?&gt; removedHandler = pendingHandshakes.remove(requestId);</span><br><span class="line">            <span class="comment">// in the case of a timeout or an exception on the send part the handshake has not been removed yet.</span></span><br><span class="line">            <span class="comment">// but the timeout is tricky since it's basically a race condition so we only assert on the success case.</span></span><br><span class="line">            <span class="keyword">assert</span> success &amp;&amp; removedHandler == <span class="keyword">null</span> || success == <span class="keyword">false</span> : <span class="string">"handler for requestId ["</span> + requestId + <span class="string">"] is not been removed"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>我们来看sendRequestToChannel方法：写入request信息，通过ChannelBuffers创建出buffer</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sendRequestToChannel</span><span class="params">(DiscoveryNode node, <span class="keyword">final</span> Channel targetChannel, <span class="keyword">final</span> <span class="keyword">long</span> requestId, <span class="keyword">final</span> String action,<span class="keyword">final</span> TransportRequest request, TransportRequestOptions options, Version channelVersion,<span class="keyword">byte</span> status)</span> <span class="keyword">throws</span> IOException,</span></span><br><span class="line"><span class="function">        TransportException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (compress) &#123;</span><br><span class="line">            options = TransportRequestOptions.builder(options).withCompress(<span class="keyword">true</span>).build();</span><br><span class="line">        &#125;</span><br><span class="line">        status = TransportStatus.setRequest(status);</span><br><span class="line">        ReleasableBytesStreamOutput bStream = <span class="keyword">new</span> ReleasableBytesStreamOutput(bigArrays);</span><br><span class="line">        <span class="keyword">boolean</span> addedReleaseListener = <span class="keyword">false</span>;</span><br><span class="line">        StreamOutput stream = Streams.flushOnCloseStream(bStream);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// only compress if asked, and, the request is not bytes, since then only</span></span><br><span class="line">            <span class="comment">// the header part is compressed, and the "body" can't be extracted as compressed</span></span><br><span class="line">            <span class="keyword">if</span> (options.compress() &amp;&amp; canCompress(request)) &#123;</span><br><span class="line">                status = TransportStatus.setCompress(status);</span><br><span class="line">                <span class="comment">// 对数据做压缩</span></span><br><span class="line">                stream = CompressorFactory.COMPRESSOR.streamOutput(stream);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// we pick the smallest of the 2, to support both backward and forward compatibility</span></span><br><span class="line">            <span class="comment">// note, this is the only place we need to do this, since from here on, we use the serialized version</span></span><br><span class="line">            <span class="comment">// as the version to use also when the node receiving this request will send the response with</span></span><br><span class="line">            <span class="comment">// 写入Version信息</span></span><br><span class="line">            Version version = Version.min(getCurrentVersion(), channelVersion);</span><br><span class="line"></span><br><span class="line">            stream.setVersion(version);</span><br><span class="line">            threadPool.getThreadContext().writeTo(stream);</span><br><span class="line">            stream.writeString(action);</span><br><span class="line">            BytesReference message = buildMessage(requestId, status, node.getVersion(), request, stream, bStream);</span><br><span class="line">            <span class="keyword">final</span> TransportRequestOptions finalOptions = options;</span><br><span class="line">            <span class="keyword">final</span> StreamOutput finalStream = stream;</span><br><span class="line">            Runnable onRequestSent = () -&gt; &#123; <span class="comment">// this might be called in a different thread</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    IOUtils.closeWhileHandlingException(finalStream, bStream);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    transportServiceAdapter.onRequestSent(node, requestId, action, request, finalOptions);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            addedReleaseListener = internalSendMessage(targetChannel, message, onRequestSent);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            IOUtils.close(stream);</span><br><span class="line">            <span class="keyword">if</span> (!addedReleaseListener) &#123;</span><br><span class="line">                IOUtils.close(stream, bStream);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h6 id="2-3-2-7-数据接收"><a href="#2-3-2-7-数据接收" class="headerlink" title="2.3.2.7 数据接收"></a>2.3.2.7 数据接收</h6><p>启动服务中的channelPipeline注册，统一的handler为MessageChannelHandler，负责消息接受及处理逻辑，在其他模块中会对不同的消息（Action）注册对应的处理程序（handler）。</p>
<p>在Netty4Transport的createBootstrap()方法中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">bootstrap.handler(getClientChannelInitializer());</span><br><span class="line"></span><br><span class="line">。。。</span><br><span class="line"><span class="function"><span class="keyword">protected</span> ChannelHandler <span class="title">getClientChannelInitializer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ClientChannelInitializer();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"> <span class="keyword">protected</span> <span class="class"><span class="keyword">class</span> <span class="title">ClientChannelInitializer</span> <span class="keyword">extends</span> <span class="title">ChannelInitializer</span>&lt;<span class="title">Channel</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(Channel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            ch.pipeline().addLast(<span class="string">"size"</span>, <span class="keyword">new</span> Netty4SizeHeaderFrameDecoder());</span><br><span class="line">            <span class="comment">// using a dot as a prefix means this cannot come from any settings parsed</span></span><br><span class="line">            ch.pipeline().addLast(<span class="string">"dispatcher"</span>, <span class="keyword">new</span> Netty4MessageChannelHandler(Netty4Transport.<span class="keyword">this</span>, <span class="string">".client"</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            Netty4Utils.maybeDie(cause);</span><br><span class="line">            <span class="keyword">super</span>.exceptionCaught(ctx, cause);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>在Netty4Transport的createServerBootstrap()方法中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">serverBootstrap.childHandler(getServerChannelInitializer(name, settings));</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> ChannelHandler <span class="title">getServerChannelInitializer</span><span class="params">(String name, Settings settings)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ServerChannelInitializer(name, settings);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">protected</span> <span class="title">ServerChannelInitializer</span><span class="params">(String name, Settings settings)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">            <span class="keyword">this</span>.settings = settings;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(Channel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            ch.pipeline().addLast(<span class="string">"open_channels"</span>, Netty4Transport.<span class="keyword">this</span>.serverOpenChannels);</span><br><span class="line">            ch.pipeline().addLast(<span class="string">"size"</span>, <span class="keyword">new</span> Netty4SizeHeaderFrameDecoder());</span><br><span class="line">            ch.pipeline().addLast(<span class="string">"dispatcher"</span>, <span class="keyword">new</span> Netty4MessageChannelHandler(Netty4Transport.<span class="keyword">this</span>, name));</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到在ClientBootStrap和ServerBootStrap中都注册了消息处理的类 MessageChannelHandler：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pipeline.addLast(<span class="string">"dispatcher"</span>, <span class="keyword">new</span> MessageChannelHandler(NettyTransport.<span class="keyword">this</span>, logger));</span><br></pre></td></tr></table></figure>
<p>MessageChannelHandler类负责消息接受及处理逻辑，在其他模块中会对不同的消息（Action）注册对应的处理程序（handler）。在对收到的内容进行解析的过程中获取到action，找到对应的handler进行处理，这个过程会交给threadpool中的线程来操作。</p>
<p>比如SearchAction的注册代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">transportService.registerHandler(SearchAction.NAME, <span class="keyword">new</span> TransportHandler());</span><br></pre></td></tr></table></figure>
<p>在TcpTransport中的messageReceived方法则是负责消息的接收。</p>
<p>至此，Transport模块我们分析完成了。</p>
<h3 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h3>
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/elasticsearch/" rel="tag"># elasticsearch</a>
          
            <a href="/tags/源码分析/" rel="tag"># 源码分析</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/05/27/ElasticSearch/elasticsearch源码分析(三)--Discover模块/" rel="next" title="elasticsearch源码分析(三)Discover模块">
                <i class="fa fa-chevron-left"></i> elasticsearch源码分析(三)Discover模块
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/06/03/ElasticSearch/elasticsearch源码分析(五)--数据写入/" rel="prev" title="elasticsearch源码分析(五)--数据写入">
                elasticsearch源码分析(五)--数据写入 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/avatar.png"
                alt="Gre World" />
            
              <p class="site-author-name" itemprop="name">Gre World</p>
              <p class="site-description motion-element" itemprop="description">原来我的代码竟然如此风骚</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives">
              
                  <span class="site-state-item-count">36</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">6</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">11</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#一、Transport模块介绍"><span class="nav-number">1.</span> <span class="nav-text">一、Transport模块介绍</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#二、源码分析"><span class="nav-number">2.</span> <span class="nav-text">二、源码分析</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#2-1-1-PreBuiltTransportClient类图关系"><span class="nav-number">2.0.1.</span> <span class="nav-text">2.1.1 PreBuiltTransportClient类图关系</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-1-2-PreBuiltTransportClient源码分析"><span class="nav-number">2.0.2.</span> <span class="nav-text">2.1.2 PreBuiltTransportClient源码分析</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-1-3-TransportClient类分析："><span class="nav-number">2.0.3.</span> <span class="nav-text">2.1.3 TransportClient类分析：</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#2-1-3-1-参数"><span class="nav-number">2.0.3.1.</span> <span class="nav-text">2.1.3.1 参数</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2-1-3-2-构造方法"><span class="nav-number">2.0.3.2.</span> <span class="nav-text">2.1.3.2 构造方法</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2-1-3-3-ClientTemplate-类分析"><span class="nav-number">2.0.3.3.</span> <span class="nav-text">2.1.3.3 ClientTemplate 类分析</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2-1-3-4-nodesService初始化"><span class="nav-number">2.0.3.4.</span> <span class="nav-text">2.1.3.4 nodesService初始化</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2-1-3-5-proxy初始化"><span class="nav-number">2.0.3.5.</span> <span class="nav-text">2.1.3.5 proxy初始化</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-RestClient初始化"><span class="nav-number">2.1.</span> <span class="nav-text">2.2 RestClient初始化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-Transport源码分析"><span class="nav-number">2.2.</span> <span class="nav-text">2.3 Transport源码分析</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#2-3-1-TransportClient调用流程"><span class="nav-number">2.2.1.</span> <span class="nav-text">2.3.1 TransportClient调用流程</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-3-2-Netty4Transport"><span class="nav-number">2.2.2.</span> <span class="nav-text">2.3.2 Netty4Transport</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#2-3-2-1-类图"><span class="nav-number">2.2.2.1.</span> <span class="nav-text">2.3.2.1 类图</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2-3-2-2-配置信息"><span class="nav-number">2.2.2.2.</span> <span class="nav-text">2.3.2.2 配置信息</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2-3-2-3-启动服务"><span class="nav-number">2.2.2.3.</span> <span class="nav-text">2.3.2.3 启动服务</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2-3-2-4-连接服务"><span class="nav-number">2.2.2.4.</span> <span class="nav-text">2.3.2.4 连接服务</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2-3-2-5-发送数据"><span class="nav-number">2.2.2.5.</span> <span class="nav-text">2.3.2.5 发送数据</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2-3-2-6-数据写入"><span class="nav-number">2.2.2.6.</span> <span class="nav-text">2.3.2.6 数据写入</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2-3-2-7-数据接收"><span class="nav-number">2.2.2.7.</span> <span class="nav-text">2.3.2.7 数据接收</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#三、总结"><span class="nav-number">3.</span> <span class="nav-text">三、总结</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>
<div class="copyright">&copy; 2016 &mdash; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Gre World</span>

  
</div>
<span id="busuanzi_container_site_pv">
    本站总访问量<span id="busuanzi_value_site_pv"></span>次
</span>
<span id="busuanzi_container_site_uv">
  本站访客数<span id="busuanzi_value_site_uv"></span>人次
</span>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>
  
  <!-- custom analytics part create by xiamo -->
<script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.1.js"></script>
<script>AV.initialize("9mpWMYP4Yg1L73KyJMTLtozv-gzGzoHsz", "BoybBq32rKIn7hzV5pLuPcls");</script>
<script>
function showTime(Counter) {
	var query = new AV.Query(Counter);
	$(".leancloud_visitors").each(function() {
		var url = $(this).attr("id").trim();
		query.equalTo("url", url);
		query.find({
			success: function(results) {
				if (results.length == 0) {
					var content = '0 ' + $(document.getElementById(url)).text();
					$(document.getElementById(url)).text(content);
					return;
				}
				for (var i = 0; i < results.length; i++) {
					var object = results[i];
					var content = object.get('time') + ' ' + $(document.getElementById(url)).text();
					$(document.getElementById(url)).text(content);
				}
			},
			error: function(object, error) {
				console.log("Error: " + error.code + " " + error.message);
			}
		});
	});
}
function addCount(Counter) {
	var Counter = AV.Object.extend("Counter");
	url = $(".leancloud_visitors").attr('id').trim();
	title = $(".leancloud_visitors").attr('data-flag-title').trim();
	var query = new AV.Query(Counter);
	query.equalTo("url", url);
	query.find({
		success: function(results) {
			if (results.length > 0) {
				var counter = results[0];
				counter.fetchWhenSave(true);
				counter.increment("time");
				counter.save(null, {
					success: function(counter) {
						var content =  counter.get('time') + ' ' + $(document.getElementById(url)).text();
						$(document.getElementById(url)).text(content);
					},
					error: function(counter, error) {
						console.log('Failed to save Visitor num, with error message: ' + error.message);
					}
				});
			} else {
				var newcounter = new Counter();
				newcounter.set("title", title);
				newcounter.set("url", url);
				newcounter.set("time", 1);
				newcounter.save(null, {
					success: function(newcounter) {
					    console.log("newcounter.get('time')="+newcounter.get('time'));
						var content = newcounter.get('time') + ' ' + $(document.getElementById(url)).text();
						$(document.getElementById(url)).text(content);
					},
					error: function(newcounter, error) {
						console.log('Failed to create');
					}
				});
			}
		},
		error: function(error) {
			console.log('Error:' + error.code + " " + error.message);
		}
	});
}
$(function() {
	var Counter = AV.Object.extend("Counter");
	if ($('.leancloud_visitors').length == 1) {
		addCount(Counter);
	} else if ($('.post-title-link').length > 1) {
		showTime(Counter);
	}
}); 
</script>
  

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.4.js"></script>
  <script>AV.initialize("9mpWMYP4Yg1L73KyJMTLtozv-gzGzoHsz", "BoybBq32rKIn7hzV5pLuPcls");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

  

  
  

  

  

  

</body>
</html>
